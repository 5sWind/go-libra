// +build js
// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: transaction_info.proto

package pbtypes

import jspb "github.com/johanbrandhorst/protobuf/jspb"

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

// `TransactionInfo` is the object we store in the transaction accumulator. It
// consists of the transaction as well as the execution result of this
// transaction. This are later returned to the client so that a client can
// validate the tree
type TransactionInfo struct {
	// Hash of the transaction that is stored.
	TransactionHash []byte
	// The root hash of Sparse Merkle Tree describing the world state at the end
	// of this transaction
	StateRootHash []byte
	// The root hash of Merkle Accumulator storing all events emitted during this
	// transaction.
	EventRootHash []byte
	// The amount of gas used by this transaction.
	GasUsed uint64
	// The major status of executing this transaction.
	MajorStatus uint64
}

// GetTransactionHash gets the TransactionHash of the TransactionInfo.
func (m *TransactionInfo) GetTransactionHash() (x []byte) {
	if m == nil {
		return x
	}
	return m.TransactionHash
}

// GetStateRootHash gets the StateRootHash of the TransactionInfo.
func (m *TransactionInfo) GetStateRootHash() (x []byte) {
	if m == nil {
		return x
	}
	return m.StateRootHash
}

// GetEventRootHash gets the EventRootHash of the TransactionInfo.
func (m *TransactionInfo) GetEventRootHash() (x []byte) {
	if m == nil {
		return x
	}
	return m.EventRootHash
}

// GetGasUsed gets the GasUsed of the TransactionInfo.
func (m *TransactionInfo) GetGasUsed() (x uint64) {
	if m == nil {
		return x
	}
	return m.GasUsed
}

// GetMajorStatus gets the MajorStatus of the TransactionInfo.
func (m *TransactionInfo) GetMajorStatus() (x uint64) {
	if m == nil {
		return x
	}
	return m.MajorStatus
}

// MarshalToWriter marshals TransactionInfo to the provided writer.
func (m *TransactionInfo) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.TransactionHash) > 0 {
		writer.WriteBytes(1, m.TransactionHash)
	}

	if len(m.StateRootHash) > 0 {
		writer.WriteBytes(2, m.StateRootHash)
	}

	if len(m.EventRootHash) > 0 {
		writer.WriteBytes(3, m.EventRootHash)
	}

	if m.GasUsed != 0 {
		writer.WriteUint64(4, m.GasUsed)
	}

	if m.MajorStatus != 0 {
		writer.WriteUint64(5, m.MajorStatus)
	}

	return
}

// Marshal marshals TransactionInfo to a slice of bytes.
func (m *TransactionInfo) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a TransactionInfo from the provided reader.
func (m *TransactionInfo) UnmarshalFromReader(reader jspb.Reader) *TransactionInfo {
	for reader.Next() {
		if m == nil {
			m = &TransactionInfo{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.TransactionHash = reader.ReadBytes()
		case 2:
			m.StateRootHash = reader.ReadBytes()
		case 3:
			m.EventRootHash = reader.ReadBytes()
		case 4:
			m.GasUsed = reader.ReadUint64()
		case 5:
			m.MajorStatus = reader.ReadUint64()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a TransactionInfo from a slice of bytes.
func (m *TransactionInfo) Unmarshal(rawBytes []byte) (*TransactionInfo, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}
