// +build js
// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: vm_errors.proto

package pbtypes

import jspb "github.com/johanbrandhorst/protobuf/jspb"

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

// The statuses and errors produced by the VM can be categorized into a
// couple different types:
// 1. Validation Statuses: all the errors that can (/should) be
//    the result of executing the prologue -- these are primarily used by
//    the vm validator and AC.
// 2. Verification Errors: errors that are the result of performing
//    bytecode verification (happens at the time of publishing).
// 3. VM Invariant Errors: errors that arise from an internal invariant of
//    the VM being violated. These signify a problem with either the VM or
//    bytecode verifier.
// 4. Binary Errors: errors that can occur during the process of
//    deserialization of a transaction.
// 5. Runtime Statuses: errors that can arise from the execution of a
//    transaction (assuming the prologue executes without error). These are
//    errors that can occur during execution due to things such as division
//    by zero, running out of gas, etc. These do not signify an issue with
//    the VM.
type VMStatus struct {
	// e.g. assertion violation, out of gas
	MajorStatus uint64
	// Any substatus code. e.g. assertion error number
	HasSubStatus bool
	SubStatus    uint64
	HasMessage   bool
	Message      string
}

// GetMajorStatus gets the MajorStatus of the VMStatus.
func (m *VMStatus) GetMajorStatus() (x uint64) {
	if m == nil {
		return x
	}
	return m.MajorStatus
}

// GetHasSubStatus gets the HasSubStatus of the VMStatus.
func (m *VMStatus) GetHasSubStatus() (x bool) {
	if m == nil {
		return x
	}
	return m.HasSubStatus
}

// GetSubStatus gets the SubStatus of the VMStatus.
func (m *VMStatus) GetSubStatus() (x uint64) {
	if m == nil {
		return x
	}
	return m.SubStatus
}

// GetHasMessage gets the HasMessage of the VMStatus.
func (m *VMStatus) GetHasMessage() (x bool) {
	if m == nil {
		return x
	}
	return m.HasMessage
}

// GetMessage gets the Message of the VMStatus.
func (m *VMStatus) GetMessage() (x string) {
	if m == nil {
		return x
	}
	return m.Message
}

// MarshalToWriter marshals VMStatus to the provided writer.
func (m *VMStatus) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.MajorStatus != 0 {
		writer.WriteUint64(1, m.MajorStatus)
	}

	if m.HasSubStatus {
		writer.WriteBool(2, m.HasSubStatus)
	}

	if m.SubStatus != 0 {
		writer.WriteUint64(3, m.SubStatus)
	}

	if m.HasMessage {
		writer.WriteBool(4, m.HasMessage)
	}

	if len(m.Message) > 0 {
		writer.WriteString(5, m.Message)
	}

	return
}

// Marshal marshals VMStatus to a slice of bytes.
func (m *VMStatus) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a VMStatus from the provided reader.
func (m *VMStatus) UnmarshalFromReader(reader jspb.Reader) *VMStatus {
	for reader.Next() {
		if m == nil {
			m = &VMStatus{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.MajorStatus = reader.ReadUint64()
		case 2:
			m.HasSubStatus = reader.ReadBool()
		case 3:
			m.SubStatus = reader.ReadUint64()
		case 4:
			m.HasMessage = reader.ReadBool()
		case 5:
			m.Message = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a VMStatus from a slice of bytes.
func (m *VMStatus) Unmarshal(rawBytes []byte) (*VMStatus, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}
