// +build js
// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: validator_change.proto

package pbtypes

import jspb "github.com/johanbrandhorst/protobuf/jspb"

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

// This is used to prove validator changes.  When a validator is changing, it
// triggers an event on /validator_change_account/events/sent.  To tell the
// client about validator changes, we query
// /validator_change_account/events/sent to get all versions that contain
// validator changes after the version that we are trying to update from. For
// each of these versions, the old validator set would have signed the ledger
// info at that version.  The client needs this as well as the event results +
// proof.  The client can then verify that these events were under the current
// tree and that the changes were signed by the old validators (and that the
// events correctly show which validators are the new validators).
//
// This message represents a single validator change event and the proof that
// corresponds to it
type ValidatorChangeEventWithProof struct {
	LedgerInfoWithSigs *LedgerInfoWithSignatures
	EventWithProof     *EventWithProof
}

// GetLedgerInfoWithSigs gets the LedgerInfoWithSigs of the ValidatorChangeEventWithProof.
func (m *ValidatorChangeEventWithProof) GetLedgerInfoWithSigs() (x *LedgerInfoWithSignatures) {
	if m == nil {
		return x
	}
	return m.LedgerInfoWithSigs
}

// GetEventWithProof gets the EventWithProof of the ValidatorChangeEventWithProof.
func (m *ValidatorChangeEventWithProof) GetEventWithProof() (x *EventWithProof) {
	if m == nil {
		return x
	}
	return m.EventWithProof
}

// MarshalToWriter marshals ValidatorChangeEventWithProof to the provided writer.
func (m *ValidatorChangeEventWithProof) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.LedgerInfoWithSigs != nil {
		writer.WriteMessage(1, func() {
			m.LedgerInfoWithSigs.MarshalToWriter(writer)
		})
	}

	if m.EventWithProof != nil {
		writer.WriteMessage(2, func() {
			m.EventWithProof.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals ValidatorChangeEventWithProof to a slice of bytes.
func (m *ValidatorChangeEventWithProof) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ValidatorChangeEventWithProof from the provided reader.
func (m *ValidatorChangeEventWithProof) UnmarshalFromReader(reader jspb.Reader) *ValidatorChangeEventWithProof {
	for reader.Next() {
		if m == nil {
			m = &ValidatorChangeEventWithProof{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.LedgerInfoWithSigs = m.LedgerInfoWithSigs.UnmarshalFromReader(reader)
			})
		case 2:
			reader.ReadMessage(func() {
				m.EventWithProof = m.EventWithProof.UnmarshalFromReader(reader)
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ValidatorChangeEventWithProof from a slice of bytes.
func (m *ValidatorChangeEventWithProof) Unmarshal(rawBytes []byte) (*ValidatorChangeEventWithProof, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}
